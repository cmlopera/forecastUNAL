% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regexpoErrorARMAv03.R
\name{regexpoErrorARMAv03}
\alias{regexpoErrorARMAv03}
\title{Función \code{regexpoErrorARMAv03()}}
\usage{
regexpoErrorARMAv03(
  respuesta,
  data,
  newdata,
  level = 0.95,
  control = stats::nls.control(),
  order = c(0L, 0L, 0L),
  seasonal = list(order = c(0L, 0L, 0L), period = NA),
  fixed = NULL,
  method = c("CSS-ML", "ML", "CSS"),
  optim.method = "BFGS",
  optim.control = list()
)
}
\arguments{
\item{respuesta}{Un objeto \code{ts} univariado con los datos a ser ajustados.}

\item{data, newdata}{Objetos tipo \code{data.frame}, cuyas columnas corresponden a los valores de las variables predictoras del modelo en el ajuste y en el pronóstico, respectivamente.}

\item{level}{Nivel de confianza para intervalos de predicción, dado como un valor en \verb{(0,1)}, por defecto es 0.95.}

\item{control}{Una lista opcional de configuraciones de control para la función \code{nls()}. Consulte \code{nls.control()} para conocer los nombres de los parámetros de control configurables y sus efectos.}

\item{order}{La especificación de la parte no estacional del modelo ARIMA. Los tres componentes \verb{(p,d,q)} son los órdenes AR, de diferenciación y el orden MA, respectivamente.}

\item{seasonal}{La especificación de la parte estacional del modelo ARIMA, más el período (que por defecto es \code{frequency(respuesta)}). Este argumento debe ser dado como una lista, con el orden de los componentes y el período, pero una especificación de solo un vector numérico de longitud 3 se convertirá en una lista adecuada con las especificaciones de los órdenes estacionales \verb{(P,D,Q)} de la parte AR, de la diferenciación y del orden MA, de periodo \code{s=frequency(respuesta)}.}

\item{fixed}{Un vector numérico opcional de la misma longitud que la suma de los órdenes de la ecuación del ARMA estacionario de media cero a ajustar sobre los residuos del ajuste exponencial. Ver en la ayuda de la función \code{arima()} los detalles de este argumento.}

\item{method}{Método de ajuste, a saber, máxima verosimilitud \code{("ML")}, Máxima verosimilitud combinada con mínimos cuadrados condicionales \code{("CSS-ML")} o mínimos cuadrados condicionales \code{("CSS")}. El valor predeterminado (a menos que existan valores faltantes) es \code{"CSS-ML"}, en el cual se usan mínimos cuadrados condicionales para encontrar valores iniciales y luego aplica máxima verosimilitud.}

\item{optim.method}{El valor pasado al argumento \verb{‘method’} para \verb{‘optim’} en la funcion \code{Arima()}. Por defecto es \code{"BFGS"}.}

\item{optim.control}{Una lista de parámetros de control para \verb{‘optim’}, usados en la función \code{Arima()}.}
}
\value{
La función produce una lista con las siguientes
\itemize{
\item \code{coefficients} Una matriz con la tabla de parámetros estimados, sus errores estándar, el estadístico \code{T0} y valor P asociado. Tenga en cuenta que no hay una estimación conjunta de los parámetros de regresión de la funcion exponencial y de los parámetros del modelo ARMA del error estructural, de modo que los errores estándar provienen del ajuste separado de las dos estructuras, pero los valores p son calculados bajo una distribución t-student cuyos grados de libertad son \verb{df=n - total de parámetros}. Esta tabla puede ser extraida con la función \code{coef()} aplicada al objeto R donde se guarde la estimación del modelo.
\item \code{fitted} Objeto tipo \code{"ts"} univariado con los valores ajustados de la respuesta. Estos valores pueden ser extraidos mediante la función \code{fitted()} aplicada    sobre el objeto R donde se guarde la estimación del modelo.
\item \code{residuals} Objeto tipo \code{"ts"}univariado con los residuos del ajuste de la respuesta. Estos valores pueden ser extraidos mediante la función \code{residuals()} aplicada sobre el objeto R donde se guarde la estimación del modelo.
\item \code{sigma2} Estimación de la varianza de las innovaciones del modelo ARMA definido para el error estructural del modelo de regresión exponencial. Puede ser extraido como \code{nombre_objeto$sigma2}, donde \code{'nombre_objeto'} es el nombre del objeto R donde se guarda la estimación del modelo.
\item \code{forecast} Objeto tipo \code{"mts"}, \code{"ts"}, \code{"matrix"}, \code{"array"}, con los pronósticos puntuales y por intervalos de la respuesta para \code{h=nrow(newdata)} períodos después del ajuste.
}
}
\description{
Ajusta y pronostica de forma aproximada modelos de regresión exponenciales como el considerado en la función de usuario \code{regexponencialv02()}, pero con error ARMA, así: primero estima los parámetros de la regresión exponencial por mínimos cuadrados no lineales, luego ajusta a los residuos de este modelo un ARMA estacionario de media cero, mediante la funcion \code{Arima()} de la libreria \code{forecast}. Los valores estimados de la serie son aproximados sumando las estimaciones de la regresión no lineal y del modelo ARMA. El anterior procedimiento también es aplicado en la construcción de pronósticos puntuales. Intervalos de pronóstico son construidos aproximando el error estándar del error de predicción como la raíz cuadrada de la suma de la varianza estimada del error de predicción sobre el modelo ARMA y la varianza estimada (por el método delta) de la estructura exponencial evaluada en los tiempos de predicción.
}
\examples{
library(forecast)
#Serie estacional trimestral multiplicativa
#de N=155 observaciones, inicio 1956-Q1
datos <- ts(CEMENTO,freq=4,start=c(1956,1))
n <- length(datos)-4
t <- 1:n
#Variables para ajuste y pronóstico modelo exponencial
#cúbico estacional con indicadoras y error AR(6)
#serie de primeros n valores
yt <- ts(CEMENTO[t],freq=4,start=start(datos))
poli <- Mipoly(tiempo=t,grado=3)
trimestre <- seasonaldummy(yt)
#data.frame de los predictores en el ajuste
X <- data.frame(poli,trimestre)
tnuevo <- (n+1):length(datos)
#Fecha inicio predicciones
startpred <- end(ts(datos[1:(n+1)],freq=4,start=c(1956,1)))
#serie de los últimos cuatro valores
ytf <- ts(datos[tnuevo],freq=4,start=startpred)
polinuevo <- Mipoly(tiempo=tnuevo,grado=3)
trimestrenuevo <- seasonaldummy(yt,h=4)
#data.frame de los predictores  en la predicción
Xnuevo <- data.frame(polinuevo,trimestrenuevo)
modelo <- regexpoErrorARMAv03(respuesta=yt,data=X,newdata=Xnuevo,
           order=c(6,0,0),method="ML")
coef(modelo)
k <- modelo$p;k
critinfresid(residuales=residuals(modelo),npar=k)
ythat <- fitted(modelo)
plot(datos)
lines(ythat,col=2)
legend("topleft",legend=c("Observaciones","ajuste"),lty=1,col=1:2,lwd=2)
predmod <- modelo$forecast; predmod
ytpron <- predmod[,1]
accuracy(ytpron,ytf)
precisintervals(real=ytf,LIP=predmod[,2],LSP=predmod[,3])

#Gráficos para residuales
layout(rbind(c(1,2,3),c(4,5,6)))
plot(residuals(modelo),main="Residuales vs. tiempo")
abline(h=c(-2*sqrt(modelo$sigma2),0,2*sqrt(modelo$sigma2)),lty=2)
plot(as.numeric(fitted(modelo)),residuals(modelo),
     main="Residuales vs. ajustados modelo")
abline(h=c(-2*sqrt(modelo$sigma2),0,2*sqrt(modelo$sigma2)),lty=2)
acf(as.numeric(residuals(modelo)),ci.type="ma",
    main="ACF modelo",lag.max=36)
pacf(as.numeric(residuals(modelo)),main="PACF modelo",lag.max=36)
qqnorm(residuals(modelo),main="Grafico Normal Residuales")
qqline(residuals(modelo),col=2,lwd=2)

#Pruebas Ljung-Box
BPLBtest(residuals(modelo),maxlag=36,type="Ljung")
#Test de normalidad
shapiro.test(residuals(modelo))
}
