% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SuavizamientoEstacional.R
\name{SuavizamientoEstacional}
\alias{SuavizamientoEstacional}
\title{Función \code{SuavizamientoEstacional()}}
\usage{
SuavizamientoEstacional(
  serie,
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  seasonal = "additive",
  h = 1,
  optim.start = c(alpha = 0.3, beta = 0.1, gamma = 0.1),
  optim.control = list()
)
}
\arguments{
\item{serie}{Un objeto tipo \code{ts} de frecuencia \code{s}.}

\item{alpha}{Parámetro de suavizamiento del nivel, debe ser un valor entre 0 y 1. Por defecto es \code{NULL}, en este caso, será hallado minimizando el SSE del ajuste.}

\item{beta}{Parámetro de suavizamiento de la pendiente, debe ser un valor entre 0 y 1. Por defecto es \code{NULL}, en este caso, será hallado minimizando el SSE del ajuste.}

\item{gamma}{Parámetro de suavizamiento de los efectos estacionales, debe ser un valor entre 0 y 1. Por defecto es \code{NULL}, en este caso, será hallado minimizando el SSE del ajuste.}

\item{seasonal}{Cadena de caracteres para indicar el tipo de descomposición, por defecto es \code{"additive"} para el caso aditivo. Para el caso multiplicativo se define como \code{"multiplicative"}.}

\item{h}{Número de pronósticos que se realizarán inmediatamente después del ajuste. Por defecto es 1.}

\item{optim.start}{Vector con componentes de nombres \code{alpha}, \code{beta} y \code{gamma}, de los valores iniciales de los parámetros de suavizamiento pasados al optimizador.}

\item{optim.control}{Lista con parámetros de control adicionales pasados a \code{optim}.}
}
\value{
La función produce un objeto tipo lista con los siguientes componentes:
\itemize{
\item \code{coefficients} Un \code{data.frame} con una sola columna de longitud \code{s+2}, con los valores finales suavizados del nivel, la pendiente y los efectos estacionales (estos ultimos en el orden \verb{i=1, 2, ...,s}).
\item \code{fitted} Objeto \code{ts} de los valores ajustados, con la misma frecuencia de \code{serie} pero iniciando en el tiempo \code{s+1}.
\item \code{residuals} Objeto \code{ts} de los residuos de ajuste con la misma frecuencia de \code{serie}.
\item \code{forecast} Objeto serie de tiempo multivariada (\code{mts}), con los pronósticos puntuales (columna 1), y límites de predicción del 95\% de confianza (columnas 2 y 3), por defecto, para \code{h=1} períodos después del ajuste.
\item \code{MSE} El MSE aproximado del ajuste.
}
}
\description{
Sobre un objeto \code{ts} realiza ajuste y predicción por suavizamiento exponencial Holt-Winters aditivo o multiplicativo. El suavizamiento puede ser óptimo o con valores predefinidos para los parámetros de suavizamiento. Usa la función R \code{HoltWinters()} pero presenta en orden de los periodos del año las últimas estimaciones suavizadas de los efectos estacionales.
}
\examples{
#Serie estacional trimestral multiplicativa de N=155 observaciones, inicio 1956-Q1
CEMENTO
datos <- ts(CEMENTO,freq=4,start=c(1956,1))
plot(datos)
t <- 1:151
yt <- ts(CEMENTO[t],freq=4,start=c(1956,1)) #serie de primeros 151 valores
#Fecha inicio predicciones
startpred <- end(ts(CEMENTO[1:152],freq=4,start=c(1956,1)))
#serie últimos cuatro valores
ytf <- ts(CEMENTO[152:length(CEMENTO)],freq=4,start=startpred)

#Ajuste por SEHW multiplicativo óptimo con n=151 y predicción con h=4
modelo <- SuavizamientoEstacional(yt,seasonal="multiplicative",h=4)
ythat <- fitted(modelo) #serie de valores ajustados

#Gráfica del ajuste
plot(datos)
lines(ythat,col=2)
legend("topleft",legend=c("Original","Ajustada SEHW"),col=c(1,2),lty=1)

#Calculando de forma aproximada AIC y BIC usando exp(C*n(p))
numpar <- frequency(datos)+1 #Aprox. del número de parámetros
Criterios <- critinfresid(residuales=residuals(modelo),npar=numpar)
Criterios

#Gráficos de residuos
MSE <- modelo$MSE; MSE #MSE aproximado del ajuste total del Suavizamiento
diagresTSModel(modelo=modelo,RMSE=sqrt(MSE),all=FALSE,single=FALSE)

#Predicciones puntuales y por IPs del 95\% de confianza
predicciones <- modelo$forecast
predicciones
#Precisión de las predicciones
forecast::accuracy(predicciones[,1],ytf)
precisintervals(real=ytf,LIP=predicciones[,2],LSP=predicciones[,3])
}
