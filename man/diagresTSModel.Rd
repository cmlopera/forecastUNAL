% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagresTSModel.R
\name{diagresTSModel}
\alias{diagresTSModel}
\title{Función \code{diagresTSModel()}}
\usage{
diagresTSModel(modelo, RMSE, all = FALSE, single = TRUE, lagmax = 36)
}
\arguments{
\item{modelo}{Un objeto R con el ajuste de un modelo de serie de tiempo. Puede ser de clase \code{lm}, \code{nls}, \code{Arima}, \code{HoltWinters}, entre otros manejados en la asignatura.}

\item{RMSE}{Un valor numérico correspondiente a una estimación de la desviación estándar del error de ajuste. Se requiere para las líneas horizontales pasando por \code{-2*RMSE} y \code{+2*RMSE.}}

\item{all}{Argumento lógico. Por defecto es FALSE indicando que solo los gráficos de residuos vs. tiempo y vs. valores ajustados serán producidos. Si es \code{TRUE}, exhibe además los gráficos de ACF y PACF muestrales, de probabilidad normal, test Shapiro-Wilks y Tests Ljung-Box para \verb{m=6, 12,...}, hasta máximo múltiplo de 6 menor o igual a \code{lagmax}.}

\item{single}{Un valor lógico. Por defecto es \code{TRUE} indicando que cada gráfica debe ser presentada en ventana independiente. Si se ajusta a \code{FALSE} y \code{all=FALSE}, los dos gráficos de residuos son presentados en una sola ventana en un arreglo de \verb{2x1}, y si \code{all=TRUE}, los cinco gáficos que se generan son presentados en una sola ventana, en un arreglo de \verb{3x2}.}

\item{lagmax}{Valor numérico indicando el máximo orden de rezago a considerar en gráficos de la ACF y PACF muestrales y en las pruebas Ljung-Box. Por defecto su valor es 36.}
}
\value{
La función no genera ningún tipo de objeto R sobre el cual luego pueda obtenerse algún valor o resultado, solo las gráficas pedidas y pruebas en consola R.
}
\description{
Genera gráficos de residuos sobre modelos de series de tiempo. Adicionalmente, puede generar la ACF, PACF muestrales, el gráfico de probabilidad normal, test Shapiro-Wilks y Tests Ljung-Box.
}
\examples{
library(forecast)
library(lmtest)
library(car)
datos <- ts(CEMENTO,fre=4,start=c(1956,1))
n <- length(datos)-4
t <- 1:n
yt <- ts(datos[t],frequency=4,start=c(1956,1))
poli <- Mipoly(tiempo=t,grado=3)
trimestre <- seasonaldummy(yt)
X <- data.frame(poli,trimestre) #La matriz de los predictores en el ajuste

#Modelo log cúbico estacional con indicadoras
modelo1 <- lm(log(yt)~.,data=X)
summary(modelo1)
diagresTSModel(modelo=modelo1,RMSE=summary(modelo1)$sigma)
diagresTSModel(modelo=modelo1,RMSE=summary(modelo1)$sigma,all=TRUE,single=TRUE)
diagresTSModel(modelo=modelo1,RMSE=summary(modelo1)$sigma,all=TRUE,single=FALSE)
diagresTSModel(modelo=modelo1,RMSE=summary(modelo1)$sigma,all=FALSE,single=FALSE)

#Modelo exponencial cúbico estacional con indicadoras
modelo2b <- regexponencialv02(respuesta=yt,data=X)
summary(modelo2b)
diagresTSModel(modelo=modelo2b,RMSE=summary(modelo2b)$sigma,all=TRUE,single=FALSE)

#Modelo log cúbico estacional con errores AR(6)
modelo2 <- Arima(log(yt),order=c(6,0,0),xreg=as.matrix(X),method="ML")
df2 <- n-length(coef(modelo2)[coef(modelo2)!=0])
coeftest(modelo2,df=df2)
diagresTSModel(modelo=modelo2,RMSE=sqrt(modelo2$sigma2),all=TRUE,single=FALSE)

#Suavizamiento Holt-Winters multiplicativo con predicción de h=4 trimestres
modelo3 <- SuavizamientoEstacional(yt,seasonal="multiplicative",h=4)
diagresTSModel(modelo=modelo3,RMSE=sqrt(modelo3$MSE),all=TRUE,single=FALSE)

#Combinación filtros de descomposición multiplicativa y
#Loess cuadrático óptimo con span según criterio AICC
modelo4 <- DescompLoessv02(serie.ajuste=yt,tipo.descomp="multiplicative",
           grado=2,criterio="aicc",h=4,level=0.95)
diagresTSModel(modelo=modelo4,RMSE=sqrt(modelo4$MSE),all=TRUE,single=FALSE)
}
